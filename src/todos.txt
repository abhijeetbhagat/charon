-check pop operations
-track block beginnings - Done
-unit test blocks - Done

-work on expressions - WIP
-learn type erasure
-learn traits from http://huonw.github.io

For your use case, you could do something like `fn visit<T: Visitable>(visitable: T)(self)`
and then have a trait Visitable that's impl'ed for each visitable type.+

-Add a method in block to add statements
-Remove data for LuaType


use std::cell::RefCell;
use std::collections::{HashMap};
use std::rc::Rc;

struct S;

struct B{
    st : RefCell<HashMap<String, String>>,
    s : Vec<S>
}

impl B{
    fn new()->Self{
        B {st:RefCell::new(HashMap::new()), s: vec![S]}
    }
}

struct A<'a>{
    a : Vec<RefCell<&'a B>>
}

impl<'a> A<'a>{
    fn new()->Self{
        A {a : Vec::new()}
    }

    fn foo(&mut self, b : &'a B){
        self.a.push(RefCell::new(b));
        for s in &b.s{
            self.bar(s);
        }

        assert_eq!(self.a.last().unwrap().borrow().st.borrow().is_empty(), false);
        self.a.pop();
    }

    fn bar(&mut self, s : &'a S){
        let mut block = self.a.last_mut().unwrap().borrow_mut();
        block.st.borrow_mut().insert("a".to_string(), "i32".to_string());
        assert_eq!(block.st.borrow().is_empty(), false);
    }
}

fn main(){
    let mut b = B::new();
    let mut a = A::new();
    a.foo(&b);
}
